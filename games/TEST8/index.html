<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <!-- 禁止缩放，确保触控体验 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber Landscape // 赛博山脉</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: monospace;
        }
        canvas { display: block; }

        /* 隐藏视频源 */
        #input-video {
            position: absolute;
            top: 0; left: 0;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* 启动遮罩层 (解决手机权限和自动播放限制) */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); 
            z-index: 9999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }

        .intro-text {
            color: #00fff7;
            font-size: 14px;
            letter-spacing: 2px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(0, 255, 247, 0.5);
            text-align: center;
            line-height: 1.5;
        }

        #start-btn {
            padding: 15px 40px;
            border: 1px solid #00fff7;
            background: rgba(0, 255, 247, 0.1);
            color: #00fff7;
            font-size: 16px;
            letter-spacing: 4px;
            cursor: pointer;
            font-family: monospace;
            box-shadow: 0 0 15px rgba(0, 255, 247, 0.2);
            transition: all 0.3s ease;
        }

        #start-btn:active {
            background: #00fff7;
            color: #000;
        }

        /* 状态提示 */
        #status-msg {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            color: #008888;
            font-size: 10px;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 2;
        }
    </style>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- 启动界面 -->
    <div id="start-overlay">
        <div class="intro-text">赛博山脉 // 交互演示<br>需要访问摄像头</div>
        <button id="start-btn">点击启动</button>
    </div>

    <div id="status-msg"></div>

    <!-- 视频元素 (iOS 必须加 playsinline) -->
    <video id="input-video" playsinline muted autoplay webkit-playsinline></video>

    <script>
        // ================= 配置参数 =================
        const CONFIG = {
            particleCount: 250000, // 略微降低粒子数以优化手机性能
            rangeX: 120,           
            rangeZ: 140,           
            lineCount: 400,        
            colorRiver: new THREE.Color('rgba(253,232,3,0.94)'), 
            colorMtBase: new THREE.Color('#002044'), 
            colorMtTop: new THREE.Color('#00fff7')   
        };

        // ================= 1. Three.js 场景 =================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#000000');
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 15, 40); 
        camera.lookAt(0, 0, -20);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // ================= 2. 几何体生成 =================
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const randoms = []; 
        const lineIndices = []; 

        const pointsPerLine = Math.floor(CONFIG.particleCount / CONFIG.lineCount);

        for (let i = 0; i < CONFIG.lineCount; i++) {
            const z = (i / CONFIG.lineCount - 0.5) * CONFIG.rangeZ;
            for (let j = 0; j < pointsPerLine; j++) {
                const x = (j / pointsPerLine - 0.5) * CONFIG.rangeX;
                positions.push(x, 0, z);
                randoms.push(Math.random(), Math.random(), Math.random());
                lineIndices.push(i / CONFIG.lineCount);
            }
        }

        // 悬浮光尘
        const dustCount = 20000;
        for(let i=0; i<dustCount; i++) {
            positions.push(
                (Math.random()-0.5)*CONFIG.rangeX,
                Math.random()*30 + 10,
                (Math.random()-0.5)*CONFIG.rangeZ
            );
            randoms.push(Math.random(), Math.random(), Math.random());
            lineIndices.push(-1.0); 
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 3));
        geometry.setAttribute('aLine', new THREE.Float32BufferAttribute(lineIndices, 1));

        // ================= 3. Shader =================
        const vertexShader = `
            uniform float uTime;
            uniform float uTerrainHeight;

            attribute vec3 aRandom;
            attribute float aLine;

            varying float vType; 
            varying float vHeight;
            varying float vIntensity;

            // 简化的噪声函数
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ; m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void main() {
                vec3 pos = position;

                if (aLine < -0.5) {
                    vType = 3.0;
                    float t = uTime * 0.2 + aRandom.x * 10.0;
                    pos.x += sin(t) * 5.0;
                    pos.z += cos(t * 0.7) * 5.0;
                    pos.y += sin(t * 1.5) * 2.0;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    gl_PointSize = (2.0) * (30.0 / -mvPosition.z);
                    return;
                }

                float riverCurve = sin(pos.z * 0.08) * 12.0 + sin(pos.z * 0.2) * 4.0;
                float distToRiver = abs(pos.x - riverCurve);

                float height = 0.0;
                float pointSize = 0.0;

                if (distToRiver < 3.5) {
                    vType = 0.0;
                    float flow = snoise(vec2(pos.x * 0.5, pos.z * 0.2 - uTime * 0.8));
                    height = flow * 0.8;
                    pointSize = 3.0 * (1.0 - distToRiver / 3.5);
                    vIntensity = 0.8 + 0.5 * sin(uTime * 5.0 + aRandom.x * 20.0);
                }
                else if (distToRiver < 10.0) {
                    vType = 2.0;
                    pointSize = 0.0; 
                }
                else {
                    vType = 1.0;
                    float mDist = distToRiver - 10.0;
                    float n1 = snoise(vec2(pos.x * 0.05, pos.z * 0.08));
                    float n2 = snoise(vec2(pos.x * 0.15, pos.z * 0.15));

                    height = (abs(n1) * 15.0 + n2 * 5.0) * (mDist * 0.08);
                    height = clamp(height, 0.0, 35.0);

                    // 高度控制
                    height *= uTerrainHeight;

                    pointSize = 1.5 + height * 0.08;
                    
                    float linePattern = sin(aLine * 300.0);
                    if (linePattern > 0.8) {
                        pointSize *= 1.5;
                        vIntensity = 1.5;
                    } else {
                        vIntensity = 0.8;
                    }
                }

                pos.y = height;
                vHeight = height;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = pointSize * (40.0 / -mvPosition.z);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColorRiver;
            uniform vec3 uColorMtBase;
            uniform vec3 uColorMtTop;

            varying float vType;
            varying float vHeight;
            varying float vIntensity;

            void main() {
                if (vType > 1.5 && vType < 2.5) discard;
                vec2 uv = gl_PointCoord.xy - 0.5;
                float d = length(uv);
                if (d > 0.5) discard;
                float alpha = 1.0 - smoothstep(0.2, 0.5, d);

                vec3 color = vec3(0.0);

                if (vType < 0.5) {
                    color = uColorRiver;
                    color += vec3(0.4, 0.4, 0.2);
                } else if (vType > 2.5) {
                    color = vec3(1.0);
                    alpha *= 0.5;
                } else {
                    float hFactor = clamp(vHeight / 25.0, 0.0, 1.0);
                    color = mix(uColorMtBase, uColorMtTop, hFactor);
                    color *= vIntensity;
                    if (hFactor > 0.8) color += vec3(0.2);
                }
                gl_FragColor = vec4(color, alpha);
            }
        `;

        const uniforms = {
            uTime: { value: 0 },
            uTerrainHeight: { value: 0.5 }, 
            uColorRiver: { value: CONFIG.colorRiver },
            uColorMtBase: { value: CONFIG.colorMtBase },
            uColorMtTop: { value: CONFIG.colorMtTop }
        };

        const material = new THREE.ShaderMaterial({
            vertexShader, fragmentShader, uniforms,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        const worldGroup = new THREE.Group();
        worldGroup.add(particleSystem);
        scene.add(worldGroup);

        // ================= 4. 控制逻辑与摄像头初始化 =================
        
        let isHandDetected = false;
        
        // 目标值
        let targetTerrainHeight = 0.5; 
        let targetGlobalScale = 1.0;   

        // 状态保持变量
        let lastHandDetectedTime = 0;
        let lastKnownHeight = 0.5;
        let lastKnownScale = 1.0;
        const GRACE_PERIOD = 2000; 

        // 当前值 (Lerp)
        let currentTerrainHeight = 0.5;
        let currentGlobalScale = 1.0;
        let autoIdleTime = 0;

        const videoElement = document.getElementById('input-video');
        const startBtn = document.getElementById('start-btn');
        const startOverlay = document.getElementById('start-overlay');
        const statusMsg = document.getElementById('status-msg');

        // MediaPipe 设置
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Lite 模型，手机端更快
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // 手势逻辑处理
        hands.onResults((results) => {
            const now = performance.now();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                lastHandDetectedTime = now;

                const hand = results.multiHandLandmarks[0];

                // --- 逻辑 1: 高度控制 (正向逻辑) ---
                const y = hand[9].y; // 0=顶(高), 1=底(低)
                
                // 优化：只要 y > 0.95 就视为完全平原
                let safeY = Math.min(y, 0.95); 
                let normY = safeY / 0.95;      
                
                // 公式：(1.0 - normY)
                // 手在顶(normY=0) -> 1.0 -> 乘以系数变成高山
                // 手在底(normY=1) -> 0.0 -> 平原
                targetTerrainHeight = (1.0 - normY) * 2.0; 

                // --- 逻辑 2: 缩放 (捏合) ---
                const p1 = hand[4]; 
                const p2 = hand[8]; 
                const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                const normDist = Math.max(0, Math.min(1, (dist - 0.02) / 0.25));
                targetGlobalScale = 0.6 + normDist * 0.8; 

                // 记录最后已知状态
                lastKnownHeight = targetTerrainHeight;
                lastKnownScale = targetGlobalScale;

            } else {
                isHandDetected = false;
            }
        });

        // 核心：点击按钮启动摄像头
        startBtn.addEventListener('click', async () => {
            startBtn.innerText = "正在连接...";
            statusMsg.innerText = "正在初始化视觉系统...";
            
            try {
                // 请求前置摄像头，使用 ideal 避免分辨率不支持报错
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        facingMode: 'user', 
                        width: { ideal: 320 },
                        height: { ideal: 240 }
                    }
                });

                videoElement.srcObject = stream;
                
                // 用户手势触发播放，解决 NotAllowedError
                await videoElement.play();
                
                // 成功后隐藏遮罩
                startOverlay.style.opacity = 0;
                setTimeout(() => startOverlay.style.display = 'none', 500);
                statusMsg.innerText = ""; 

                // 开始 MediaPipe 处理循环
                processVideo();

            } catch (err) {
                console.error(err);
                startBtn.innerText = "重试";
                statusMsg.innerText = "错误: " + err.message;
            }
        });

        async function processVideo() {
            if (videoElement.readyState >= 2) {
                await hands.send({image: videoElement});
            }
            requestAnimationFrame(processVideo);
        }

        // ================= 5. 动画循环 =================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            const now = performance.now();

            // 自动模式逻辑 (带防抖)
            if (!isHandDetected) {
                if (now - lastHandDetectedTime < GRACE_PERIOD) {
                    targetTerrainHeight = lastKnownHeight;
                    targetGlobalScale = lastKnownScale;
                } else {
                    autoIdleTime += 0.005;
                    targetTerrainHeight = 0.6 + Math.sin(autoIdleTime) * 0.4;
                    targetGlobalScale = 1.0 + Math.sin(autoIdleTime * 0.7) * 0.1;
                }
            }

            // 平滑插值
            const lerpFactor = 0.08;
            currentTerrainHeight += (targetTerrainHeight - currentTerrainHeight) * lerpFactor;
            currentGlobalScale += (targetGlobalScale - currentGlobalScale) * lerpFactor;

            // 更新 Shader 和 场景
            uniforms.uTime.value = t;
            uniforms.uTerrainHeight.value = currentTerrainHeight;
            worldGroup.scale.set(currentGlobalScale, currentGlobalScale, currentGlobalScale);
            worldGroup.rotation.y = Math.sin(t * 0.05) * 0.05;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>